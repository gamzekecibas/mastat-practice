---
title: "PrinStat - Lab 2: PhD in UGent"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

Load the necessary packages for this Notebook:

```{r init}
library(car)
library(tidyverse)
```

## Read data

Read data from provided file that has .dat extension:

```{r}
dat <- read.table(file.choose(), header = TRUE)
```

Some functions for a first exploration:

```{r}
head(dat)
```

```{r}
tail(dat)
```

```{r}
names(dat)
```

```{r}
dim(dat)
```

```{r}
str(dat)
```

```{r}
dat$gender
```

```{r}
with(dat, gender)
```

## Univariate descriptives

### Categorical variables

```{r}
with(dat, str(gender))
```

Let's see how many men/women/... are in this lab:

```{r}
with(dat, table(gender))
```

To explicitly let R know that level `""` is in fact a **missing value**, we need to recode `Gender` by assigning the new value `NA` to observations with `Gender == ""` (another option is to use `ifelse()` - see below).

```{r}
with(dat, is.na(gender))
```

```{r}
with(dat, gender[1])
```

```{r}
with(dat, gender[dat$gender == "W"])
```

However, R does not consider `Gender` to be a factor (with either two or three levels):

```{r}
with(dat, levels(gender))
```

By recoding it as a factor, the empty level `""` becomes a third level. Such transforming of a variable can be done with tidyverse's function `mutate()` (from the subpackage **dplyr**) or with R's base function `within()` (but **not** with the deprecated function `transform()`):

```{r}
dat <- within(dat, gender <- factor(gender))
with(dat, levels(gender))
```

The empty level can be excluded from the computations:

```{r}
with(dat, table(gender, exclude = NULL))    # show missing values
```

```{r}
with(dat, table(gender, exclude = ""))    # without missing values
```

By replacing empty levels with `NA`, they are only dropped by coding the transformed variable again as a factor. However, don't forget to include them in your computations if you want to report missing values:

```{r}
with(dat, gender)
```

```{r}
dat <- within(dat, gender <- factor(na_if(as.character(gender), "")))
with(dat, is.na(gender))
```

```{r}
with(dat, table(gender, exclude = NULL))
```

Now, everything in percentages, using the function `prop.table()`:

```{r}
with(dat, prop.table(table(gender, exclude = NULL)))
```

```{r}
tab <- with(dat, table(gender, exclude = NULL))
tab
```

```{r}
prop.table(tab)
```

The proper graph for a categorical variable is a **bar chart**:

```{r}
with(dat, plot(gender, ylab = "Absolute Frequency", xlab = "gender",
               main = "Barplot of Gender whose PhD@UGent"))
```


```{r}
barplot(tab, ylab = "Absolute Frequency",
        names.arg = c("Men (M)", "Women (W)", "NA"), xlab = "gender", 
        main = "Barplot of Gender whose PhD@UGent")
```

```{r}
barplot(tab / length(dat$gender), ylab = "Percentage",
        names.arg = c("Men (M)", "Women (W)", "NA"), xlab = "Gender")
```

```{r}
plt_Gender <- ggplot(data = dat, mapping = aes(x = gender)) +
  geom_bar(fill = "skyblue")
plt_Gender
```

```{r}
ggplot(data = dat, mapping = aes(x = gender)) +
  geom_bar(fill = "skyblue", mapping = aes(y = after_stat(prop), group = 1)) +
  labs(y = "percent")
```

We investigate some other categorical variables (or "factors"):

```{r}
with(dat, belgian)
```

```{r}
dat <- within(dat, belgian <- na_if(belgian, ""))
with(dat, belgian)
```

```{r}
tab <- with(dat, table(belgian, exclude = NULL))
prop.table(tab)
```
```{r}
dat <- within(dat, belgian <- factor(na_if(as.character(belgian), "")))
with(dat, is.na(belgian))
```

```{r}
with(dat, plot(belgian, ylab = "Absolute Frequency",
               xlab = "Belgian Nationality", 
               main = "Nationalities of PhD@UGent"))
```
```{r}
tab <- with(dat, table(belgian, exclude = NULL))
tab
```

```{r}
barplot(tab, xlab = "Nationality", ylab = "Absolute Frequency",
        names.arg = c("Belgian", "Other", "NA"))
```

```{r}
barplot(prop.table(tab), xlab = "Nationality", ylab = "Relative Frequency",
        names.arg = c("Belgian", "Other", "NA"))
```

```{r}
ggplot(data = dat, mapping = aes(x = belgian)) + geom_bar(fill = "wheat")
```

```{r}
with(dat, `faculty`)
```

```{r}
dat <- within(dat,
              faculty <- factor(na_if(`faculty`, "")))
with(dat, table(faculty, exclude = NULL))
```

```{r}
tab <- with(dat, table(faculty, exclude = NULL))
tab
```

```{r}
prop.table(tab)
```

```{r}
with(dat, plot(faculty))
```

```{r}
barplot(tab)    # also plots missing values
```

In **ggplot2** we can create a horizontal bar chart by specifying the factor (`Academic_background`) to `y` aesthetic (instead of `x`):

```{r}
ggplot(data = dat, mapping = aes(y = faculty)) +
  geom_bar(fill = "blue")
```

```{r}
with(dat, `phd`)
```

```{r}
dat <- within(dat, phd <- factor(na_if(`phd`, "")))
with(dat, str(phd))
```

```{r}
with(dat, plot(phd))
```

```{r}
with(dat, `level`)
```

```{r}
dat <- within(dat, level <- na_if(`level`, ""))
with(dat, str(level))
```

We can convert `R.skills` into an ordinal variable by using the argument `ordered` in `factor()`:

```{r}
dat <- within(dat, level <- factor(level, ordered = TRUE))
with(dat, str(level))
```

```{r}
dat <- within(dat,
              level <- factor(`level`))
with(dat, table(level, exclude = NULL))
```


```{r}
with(dat, plot(level))
```

```{r}
with(dat, `class`)
```

```{r}
dat <- within(dat,
              class <- na_if(`class`, ""))
```

Change labels to make them shorter (but again specify them in the same order as the current order, because otherwise you also need to use the argument `levels`):

```{r}
dat <- within(dat,
              class <- factor(class))
with(dat, plot(class))
```

### Numeric/Continuous variables

```{r}
with(dat, `Distance to class`)
```

```{r}
with(dat, str(`Distance to class`))
```

How many missing values?

```{r}
with(dat, sum(is.na(`Distance to class`)))
```

In tidyverse, the function `arrange()` (of the subpackage **dplyr**) can be used to order a data frame on the basis of the values in particular columns. The default is ascending order (i.e. from the smallest to the largest value) but the function `desc()` can be used to sort in descending order (i.e. from the largest to the smallest value):

```{r}
dat %>% arrange(`Distance to class`)
```

```{r}
dat %>% arrange(desc(`Distance to class`))
```

```{r}
dat %>% arrange(desc(`Time to get here`))
```

R of course has many functions for computing **numerical summaries** (i.e. descriptive statistics). By default, however, they return `NA` if there are any `NA`'s in your data. If you want to have the numerical summary for the non-missing data, then each of these functions has to be used with the argument `na.rm = TRUE`:

```{r}
with(dat, min(`Distance to class`))
```

```{r}
with(dat, min(`Distance to class`, na.rm = TRUE))
```

```{r}
with(dat, max(`Distance to class`, na.rm = TRUE))
```

```{r}
with(dat, range(`Distance to class`, na.rm = TRUE))
```

Various summary statistics can be combined in a vector:

```{r}
with(dat, 
     c(mean = mean(`Distance to class`, na.rm = TRUE),
       var = var(`Distance to class`, na.rm = TRUE),
       sd = sd(`Distance to class`, na.rm = TRUE))
     )
```

```{r}
# When missing values are included, no calculation
with(dat, 
     c(mean = mean(`Distance to class`),
       var = var(`Distance to class`),
       sd = sd(`Distance to class`))
     )
```

The tidyverse counterpart of this is to work with the `summarise()` function (of the **dplyr** subpackage):

```{r, paged.print = FALSE}
dat %>% summarise(
  mean = mean(`Distance to class`, na.rm = TRUE),
  var = var(`Distance to class`, na.rm = TRUE),
  sd = sd(`Distance to class`, na.rm = TRUE))
```

Some robust summaries:

```{r}
with(dat, median(`Distance to class`, na.rm = TRUE))
```

```{r}
with(dat, quantile(`Distance to class`, na.rm = TRUE))
```

```{r}
with(dat, quantile(`Distance to class`, probs = (1:10) / 10, na.rm = TRUE))
```

```{r}
with(dat, summary(`Distance to class`, na.rm = TRUE))
```

```{r}
with(dat, fivenum(`Distance to class`, na.rm = TRUE))
```

Check:

```{r}
with(dat, IQR(`Distance to class`, na.rm = TRUE))
```

```{r}
# ==
unname(with(dat,
     quantile(`Distance to class`, 0.75, na.rm = TRUE) - 
     quantile(`Distance to class`, 0.25, na.rm = TRUE)))
```

**Graphical summaries** are provided by the histogram, boxplot or QQ-plot.

**Histogram**:

```{r}
with(dat, hist(`Distance to class`))
```

```{r}
with(dat, hist(`Distance to class`, freq = FALSE))
```

```{r}
?hist
```

Identify the outliers (e.g. `` `Distance to class` `` == 10000):

```{r}
?which
```

```{r}
with(dat, which(`Distance to class` > 7000))
```

```{r}
with(dat, `Distance to class`[1])
```

```{r}
with(dat, match(10000, `Distance to class`))
```

```{r}
with(dat, which(`Distance to class` == 10000))
```

We can subset the data by excluding an observation (e.g. obs 1):

```{r}
with(dat, hist(`Distance to class`[-1], freq = FALSE))
```

```{r}
with(dat, {
  hist(`Distance to class`[-1], freq = FALSE, breaks = 20)
  lines(density(`Distance to class`[-1], na.rm = TRUE))
        })
```

The tidyverse counterpart to excluding observations is to use the function `filter()` (from the subpackage **dplyr**). Since we cannot include base R functions (like `hist()`) in pipe chains (using `%>%`), we have to create a new data set:

```{r}
sub <- dat %>% filter(`Distance to class` < 10000)
with(sub, hist(`Distance to class`, freq = FALSE))
```

```{r}
with(sub, {
  hist(`Distance to class`, freq = FALSE, breaks = 20)
  lines(density(`Distance to class`, na.rm = TRUE))
        })
```

Further on, if we use the variable `` `Distance to class` `` then we will remove the outlier(s) from the data. You could use the new data set `sub` but then you lose all the other information about this (first) observation. This is not always what we want because outliers may have valid information on all of the other variables.

**Boxplot**:

```{r}
with(dat, boxplot(`Distance to class`, ylab = "Distance to class", 
                  main = "boxplot of Distance"))
```

```{r}
with(sub, boxplot(`Distance to class`, horizontal = TRUE))
```

```{r}
with(sub, boxplot(`Distance to class`, horizontal = TRUE, outline = FALSE))
```

```{r}
?boxplot
```

The function `Boxplot()` from the package **car** is more informative than the base R function in that it plots the row ID's of the outliers:

```{r}
with(dat, Boxplot(`Distance to class`, ylab = "Distance to class", 
                  main = "boxplot of Distance"))
```

```{r}
with(sub, Boxplot(`Distance to class`, ylab = "Distance to class", 
                  main = "boxplot of Distance"))
```

**QQ-plot**: = Check for normality (relevant for various statistical tests, e.g. t-test)

With outliers:

```{r}
with(dat, {
  qqnorm(`Distance to class`)
  qqline(`Distance to class`)
})
```

Without outliers:

```{r}
with(sub, {
  qqnorm(`Distance to class`)
  qqline(`Distance to class`)
})
```

A histogram and boxplot side by side:

```{r}
?par
```

```{r}
par(mfrow = c(1, 2))    # split the screen into 1 row and 2 columns
with(sub, {
  hist(`Distance to class`, xlab = "Distance to class", main = "")
  boxplot(`Distance to class`)
})
```

```{r}
par(mfrow = c(1, 1))    # put back to default
```

Add the QQ-plot:

```{r}
?layout
```

```{r}
layout(matrix(c(1, 1, 2, 3), nrow = 2, ncol = 2, byrow = TRUE))
with(sub, {
  qqnorm(`Distance to class`)
  qqline(`Distance to class`)
  hist(`Distance to class`, xlab = "Distance to class", main = "")
  boxplot(`Distance to class`)
})
```

In tidyverse, histograms, boxplots and qq-plots can be made by choosing the appropriate "geom layers" with **ggplot2**. Note that the QQ-plot requires the numeric variable to be specified to the aesthetic `sample`:

```{r}
ggplot(data = sub, mapping = aes(x = `Distance to class`)) + geom_histogram()
```

```{r}
ggplot(data = sub, mapping = aes(x = `Distance to class`)) + geom_boxplot()
```

```{r}
ggplot(data = sub, mapping = aes(sample = `Distance to class`)) +
  geom_qq() +
  geom_qq_line()
```

These three graph types also illustrate the default connections between geom and stat layers in **ggplot2**. For instance, a histogram divides a numeric variable into bins, counts the number of observations within each bin and visualizes these bin counts as bars. That is why a histogram can also be seen as a *bar geom* with a *bin stat*, which can be made in two ways:

```{r}
ggplot(data = sub, mapping = aes(x = `Distance to class`)) + 
  geom_bar(stat = "bin")
```

```{r}
ggplot(data = sub, mapping = aes(x = `Distance to class`)) + 
  stat_bin(geom = "bar")
```

Another numeric variable:

```{r}
with(dat, str(`Time to get here`))
```

```{r}
with(dat, `Time to get here`)
```

```{r}
with(dat, is.na(`Time to get here`))    # Are there any NAs?
```

```{r}
with(dat, sum(is.na(`Time to get here`)))    # How many?
```

```{r}
with(dat, table(is.na(`Time to get here`)))  # Idem
```

```{r}
with(dat, which(is.na(`Time to get here`)))    # How do we know which obs are NAs?
```

```{r}
par(mfrow = c(1, 2))
with(dat, {
  hist(`Time to get here`, main = "", xlab = "Time to get here")
  boxplot(`Time to get here`)
})    # may also be heavily right-skewed
```

```{r}
par(mfrow = c(1, 1))    # back to default
```

```{r}
ggplot(data = dat, mapping = aes(x = `Time to get here`)) + geom_histogram()
```

```{r}
ggplot(data = dat, mapping = aes(x = `Time to get here`)) + geom_boxplot()
```

Date-Time variables are character variables with special attributes in R:

```{r}
with(dat, str(`Date of Birth`))
```

```{r}
with(dat, `Date of Birth`)
```

They can be converted to date objects, i.e. objects with class `Date`:

```{r}
?as.Date    # You may have to change the format argument:
```

You may have to change the `format` string in the following code (e.g. `"%m/%d/%Y"` or `"%Y-%m-%d"`) instead of `"%d/%m/%Y"`):

```{r}
dat <- within(dat, Birth_date <- as.Date(`Date of Birth`,
                                 format = "%d/%m/%Y")
             )  # Change the format argument if the following produces only NA's:
with(dat, Birth_date)
```

```{r}
with(dat, str(Birth_date))
```

```{r}
with(dat, is.na(Birth_date))
```

```{r}
with(dat, table(is.na(Birth_date)))
```

The bins of R's base function `hist()` can even be specified on the basis of date attributes:

```{r}
with(dat, hist(Birth_date, breaks = "years"))
```

```{r}
with(dat, hist(Birth_date, breaks = "weeks"))    # bins too thin!
```

```{r}
with(dat, hist(Birth_date, breaks = 20))
```

```{r}
with(dat, boxplot(Birth_date))
```

Date objects can be formatted with the function `format()`:

```{r}
?format
```

```{r}
with(dat, format(Birth_date, "%Y"))
```

```{r}
with(dat, Birth_date[format(Birth_date, "%Y") > 2010])
```

People born after 2010 would be **anomalies** in the *MaStat*, so are there any? If so, then you can identify them with the function `which()`:

```{r}
ind <- with(dat, which(format(Birth_date, "%Y") > 2010))
ind  # If there are none, then perhaps use: ind <- 1
```

Next, use `ind` to subset the data and/or use `-ind` to exclude them from the data:

```{r}
with(dat, Birth_date[-ind]) 
```

```{r}
with(dat, hist(Birth_date[-ind], breaks = "years"))
```

Again, the tidyverse code would be to "filter" the birth dates:

```{r}
sub <- dat %>% filter(format(Birth_date, "%Y") <= 2010)
with(sub, hist(Birth_date, breaks = "years"))
```

Dates are essentially stored as integer values in R and this can be shown by the fact that the one can be converted to the other and vice versa:

```{r}
with(dat, as.integer(Birth_date))
```

```{r}
?as.Date
```

```{r}
as.Date(4767, origin = "1970-01-01")    # default origin in R
```

```{r}
as.Date(4767, origin = "1971-01-01")
```

R's base function for returning the current date, i.e. today:

```{r}
Sys.Date()
```

```{r}
?Sys.Date
```

```{r}
as.integer(Sys.Date())
```

On the basis of this we can compute/derive a continuous age variable:

```{r}
dat <- within(dat,
              Age <- (as.integer(Sys.Date()) - as.integer(Birth_date)) / 365.25
              )
with(dat, Age)
```

The tidyverse code would be to "mutate" `Birth_date` into `Age`:

```{r}
dat <- dat %>%
  mutate(Age = (as.integer(Sys.Date()) - as.integer(Birth_date)) / 365.25)
with(dat, Age)
```

Finally, let's make a histogram for `Age`. Of course, it is identical to the histogram of `Birth_date` but mirrored vertically (since `Age` is a linear transformation of `Birth_date`):

```{r}
sub <- dat %>% filter(format(Birth_date, "%Y") <= 2010)
with(sub, hist(Age, breaks = 20, xlab = "Age (years)", main = NA))
```

## Multivariate descriptives

### Categorical x Categorical

```{r}
tab <- with(dat, table(Gender, Belgian, exclude = NULL))
tab
```

```{r}
prop.table(tab)
```

```{r}
round(prop.table(tab), digits = 1)
```

```{r}
barplot(tab)    # stacked => not very nice/insightful!
```

```{r}
barplot(tab, beside = TRUE)    # use beside argument!
```

```{r}
barplot(tab, beside = TRUE, legend.text = levels(dat$Gender),
        xlab = "Nationality", xaxt = "n")    # Necessary to also have a legend!
axis(1, at = c(2, 6.5, 10.5), labels = c("Belgian", "Other", "NA"))
```

```{r}
?par    # look up 'xaxt'
```

```{r}
?axis
```

If you want to put `Gender` on the x-axis, then you can just take the transpose of the table (matrix):

```{r}
?t
```

```{r}
with(dat, table(Belgian, Gender, exclude = NULL))    # either switch arguments
```

```{r}
t(tab)    # or take transpose
```

```{r}
barplot(t(tab), beside = TRUE, legend.text = levels(dat$Belgian),
        xlab = "Gender")
```

In **ggplot2** you put a variable on the x-axis by means of the aesthetics, but you first have convert the frequency table to a data frame (or tibble). The count variable in this data frame needs to be incorporated in the (mapping to) aesthetics but this also means that you have to use the `identity` stat (instead of the default `count` stat). Bar charts in **ggplot2** are also stacked by default so you plot the bars side-by-side with the argument `position = "dodge"`:

```{r, paged.print = FALSE}
df2 <- as.data.frame(tab)
df2
```

```{r}
ggplot(data = df2, mapping = aes(x = Gender, fill = Belgian, y = Freq)) +
  geom_bar(stat = "identity", position = "dodge") 
```

By the way, the data frame `df2` can always be (re)converted to a table by means of the function `pivot_wider()` of (the subpackage **tidyr** of) tidyverse. That function has many arguments but the most important two are:

-   `names_from`: The character column which should become the new columns
-   `values_from`: The numeric column which contains the values for the cells

```{r, paged.print = FALSE}
df3 <- df2 %>%
  pivot_wider(names_from = "Belgian", values_from = "Freq")
df3
```

The function `pivot_longer()` performs the opposite operation: it rearranges various columns underneath each other. You should should specify which columns should be rearranged and the arguments `names_to` and `values_to` have the opposite meanings to `names_from` and `values_from` in `pivot_wider()`:

```{r, paged.print = FALSE}
df4 <- df3 %>%
  pivot_longer(!Gender, names_to = "Belgian", values_to = "Freq")
df4
```

The `pivot_wider()` and `pivot_longer()` functions (of the **tidyr** subpackage) supersede the functions `spread()` and `gather()` (which are in other words deprecated) in tidyverse. Any function of the **reshape2** package is also deprecated.

Another example:

```{r}
tab <- with(dat, table(Academic_background, Gender, exclude = NULL))
tab 
```

```{r}
prop.table(tab)    # cell percentages
```

```{r}
options(digits = 1)    # change number of digits for all subsequent commands
prop.table(tab)
```

```{r}
prop.table(tab, margin = 1)    # row percentages 
```

```{r}
prop.table(tab, margin = 2)    # column percentages
```

### Categorical x Continuous

```{r, paged.print = FALSE}
with(dat, aggregate(`Time to get here` ~ Gender, FUN = mean))
```

```{r}
with(dat, mean(`Time to get here`[Gender == "female"], na.rm = TRUE))
```

```{r}
with(dat, mean(`Time to get here`[Gender == "male"], na.rm = TRUE))
```

```{r}
?aggregate
```

```{r, paged.print = FALSE}
with(dat, aggregate(`Time to get here` ~ Gender, FUN = median))
```

```{r, paged.print = FALSE}
with(dat, aggregate(`Time to get here` ~ Gender, FUN = sd))
```

Base R's `aggregate()` function has a counterpart in combining the `group_by()` function with `summarise()` of (the subpackage **dplyr** of) tidyverse:

```{r, paged.print = FALSE}
dat %>%
  group_by(Gender) %>%
  summarise(avg = mean(`Time to get here`, na.rm = TRUE),
            med = median(`Time to get here`, na.rm = TRUE),
            std = sd(`Time to get here`, na.rm = TRUE))
```

Since `Gender` is coded as a factor, the default bivariate plot with factor on the x-axis will be a (conditional) boxplot:

```{r}
with(dat, plot(Gender, `Time to get here`))
```

```{r}
with(dat, plot(`Time to get here` ~ Gender))
```

```{r}
boxplot(`Time to get here` ~ Gender, data = dat)    # will also display a boxplot
                                                    # if Gender is numerical,
                                                    # in contrast to 'plot()'!
```

Is the range in `Age` (and age distribution) about the same for male and female students?

```{r}
with(sub, boxplot(Age ~ Gender))
```

```{r}
boxplot(Age ~ Gender, data = sub)
```

```{r}
par(mfrow = c(2, 1))
with(sub, {
  hist(Age[Gender == "female"])
  hist(Age[Gender == "male"])
  })
```

```{r}
par(mfrow = c(1, 1))    # back to default
```

Special case: the **evolution of a variable** (over time)

```{r}
with(sub, plot(Birth_date, Gender))
```

```{r}
plot(as.numeric(Gender) ~ Birth_date, data = sub)
```

Add a smoother to gain more insight in `Gender` gap conditional on `Age` category (using **LOWESS** or **LOESS** = LOcally WEighted Scatterplot Smoothing):

```{r}
# All commands in one go:
plot(as.numeric(Gender) ~ Birth_date, data = sub)
with(sub, lines(loess.smooth(Birth_date, as.numeric(Gender)),
                        col = "red"))
abline(h = 1.5, lty = 2)
```

The same, but with clearer `y` labels (requires some tweaking of graphical parameters):

```{r}
?par    # look up 'yaxt'
```

```{r}
plot(as.numeric(Gender) ~ Birth_date, data = sub, yaxt = "n",
     xlab = "Birth date", ylab = "Gender")
with(sub, lines(loess.smooth(Birth_date, as.numeric(Gender)),
                        col = "red"))
abline(h = 1.5, lty = 2)
axis(2, at = c(1, 2), labels = levels(sub$Gender), las = 1)
```

In **ggplot2** the LOESS smoother is available as a geom or stat layer:

```{r}
ggplot(data = sub,
       mapping = aes(x = Birth_date, y = as.numeric(Gender))) +
  geom_point() +
  geom_smooth(se = FALSE, color = "red") +
  scale_y_continuous(breaks = c(1, 2), labels = levels(sub$Gender))
```

### Continuous x Continuous

```{r}
with(sub, {
  plot(Birth_date, Age)    # default: scatterplot
  lines(loess.smooth(Birth_date, Age), 
        col = "red", lwd = 2)
})
```

```{r}
ggplot(sub, mapping = aes(x = Birth_date, y = Age)) +
  geom_point() + 
  geom_smooth(color = "red")
```

The **correlation coefficient** expresses the (strength of the) relationship between two numeric variables. Pearson's correlation coefficient expresses a linear relationship:

```{r}
?cor
```

```{r}
with(sub, cor(as.numeric(Birth_date), Age, use = "na.or.complete"))
```

Of course, `Birth_date` and `Age` in fact encode the same information. Another example:

```{r}
sub <- dat %>% filter(`Distance to class` < 10000)
with(sub, plot(`Distance to class`, `Time to get here`))
```

```{r}
plot(`Time to get here` ~ `Distance to class`, data = sub)
with(sub, lines(loess.smooth(`Distance to class`, `Time to get here`),
                col = "red", lwd = 2))
```

```{r}
with(sub, cor(`Distance to class`, `Time to get here`, use = "na.or.complete"))
```

Is this correlation as expected?

### Continuous x Continuous x Categorical

By adding a color code to the previous scatter plot, we can also identify a categorical variable, e.g. means of transportation:

```{r}
plot(`Time to get here` ~ `Distance to class`, data = sub, 
     col = sub$Means_of_transportation, pch = 19)
legend(x = "topleft", col = 1:3,
       legend = levels(sub$Means_of_transportation),
       cex = 0.9, pch = 19)
```

Look at the order of the levels in order to know the right color code. For instance, `levels(sub$Means_of_transportation)` returns:

```         
# [1] "bike"             "car / motorbike"  "public transport"
```

Hence, color `1` = `"bike"`, `2` = `"car / motorbike"` and so on.

In **ggplot2** a third variable can be visualized by mapping it to a certain aesthetic like e.g. `color`:

```{r}
ggplot(data = sub,
       mapping = aes(x = `Distance to class`,
                     y = `Time to get here`,
                     color = Means_of_transportation)) + 
  geom_point()
```

Add LOESS smoothers for each of the means of transportation:

```{r}
# All code in one go:
plot(`Time to get here` ~ `Distance to class`, data = sub, 
     col = sub$Means_of_transportation, pch = 19)
legend(x = "topleft", col = 1:3,
       legend = levels(sub$Means_of_transportation), pch = 19)
with(subset(sub, Means_of_transportation == "bike"),
     lines(loess.smooth(`Distance to class`, `Time to get here`),
           col = 1, lwd = 2))
with(subset(sub, Means_of_transportation == "car / motorbike"),
     lines(loess.smooth(`Distance to class`, `Time to get here`),
           col = 2, lwd = 2))
with(subset(sub, Means_of_transportation == "public transport"),
     lines(loess.smooth(`Distance to class`, `Time to get here`),
           col = 3, lwd = 2))
```

Beware of extrapolation to undersampled regions!

Add regression lines instead of LOESS smoothers: use `abline()`. This in turn makes use of the function `lm()`, which stands for "linear model", since we basically plot the regression line for each linear model in which we regress time on distance, separately for the different means of transportation:

```{r}
?abline
```

```{r}
plot(Time.to.get.here ~ Distance.to.class, data = sub,
     col = sub$Means.of.transportation, pch = 19)
legend(x = "topleft", col = 1:3,
       legend = levels(sub$Means.of.transportation), pch = 19)
with(subset(sub, Means.of.transportation == "bike"),
     abline(lm(Time.to.get.here ~ Distance.to.class), col = 1))
with(subset(sub, Means.of.transportation == "car / motorbike"),
     abline(lm(Time.to.get.here ~ Distance.to.class), col = 2))
with(subset(sub, Means.of.transportation == "public transport"),
     abline(lm(Time.to.get.here ~ Distance.to.class), col = 3))
```

What information does this reveal?

### Continuous x Continuous x Continuous

As an example, let's add Age instead of means of transportation as the third variable. Instead of color coding, we can vary the size of the circles according to `Age` (larger circles = older students). This is called a **bubble plot**:

```{r}
plot(`Time to get here` ~ `Distance to class`, data = sub, pch = "")
with(subset(sub, !is.na(Age)),
     symbols(`Distance to class`, `Time to get here`, circles = Age,
             inches = 0.1, add = TRUE))
```

In **ggplot2**, bubble plots can be made with the `size` aesthetic (while the `alpha` argument controls the degree of transparency of the colors):

```{r}
ggplot(data = sub,
       mapping = aes(x = `Distance to class`,
                     y = `Time to get here`,
                     size = Age)) + 
  geom_point(alpha = 0.3)
```

It is clear that bubble plots are not always very insightful, however: people cannot think in many dimensions at once!
